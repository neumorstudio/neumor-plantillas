---
import "../styles/global.css";
import "../styles/neuglass.css";
import "../styles/skins.css";
import { compileCustomization, applyPreviewParams, type WebsiteCustomization } from "@lib/tokens";

interface Props {
  title: string;
  description?: string;
  theme?: "light" | "dark" | "colorful" | "rustic" | "elegant" | "neuglass" | "neuglass-dark" | "christmas" | "summer" | "autumn" | "spring" | "ocean" | "sunset" | "forest" | "midnight" | "rose" | "lavender" | "coral" | "minimal" | "wellness" | "vintage";
  customization?: WebsiteCustomization;
}

const {
  title,
  description = "Salon de belleza con estilo neumorfico",
  theme = "light",
  customization = {},
} = Astro.props;

// === DEBUG LOGS ===
console.log('[Layout.astro] ========== LAYOUT RENDER ==========');
console.log('[Layout.astro] Received props - theme:', theme);
console.log('[Layout.astro] Received customization:', JSON.stringify(customization, null, 2));

// Aplicar parámetros de preview si existen
const url = new URL(Astro.request.url);
const isPreviewMode = url.searchParams.get('preview') === '1';
console.log('[Layout.astro] URL:', url.toString());
console.log('[Layout.astro] Is preview mode:', isPreviewMode);

const finalCustomization = applyPreviewParams(customization, url);
console.log('[Layout.astro] finalCustomization after applyPreviewParams:', JSON.stringify(finalCustomization, null, 2));

// Compilar tokens a CSS
const { cssVariables, inlineColorStyles, fontImports, favicon } = compileCustomization(finalCustomization);
console.log('[Layout.astro] Compiled - cssVariables:', cssVariables ? 'has content' : 'empty');
console.log('[Layout.astro] Compiled - inlineColorStyles:', inlineColorStyles);
console.log('[Layout.astro] Compiled - fontImports:', fontImports);
console.log('[Layout.astro] ========================================');

// Determinar clase de tema
const themeClass = theme === "light" ? "" : `theme-${theme}`;

// Fuentes por defecto si no hay personalización
const defaultFonts = !fontImports
  ? "https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap"
  : fontImports;
---

<!doctype html>
<html lang="es" class={themeClass} style={inlineColorStyles || undefined}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content={description} />
    <meta name="generator" content={Astro.generator} />

    <!-- 1. Critical CSS - Defaults base (se sobrescriben con personalizacion) -->
    <style is:inline>
      /* Variables base - se sobrescriben con inline styles si hay personalización */
      :root {
        --neumor-bg: #e8ecf1;
        --shadow-dark: rgba(163, 177, 198, 0.6);
        --shadow-light: rgba(255, 255, 255, 0.9);
        --text-primary: #1a1a2e;
        --text-secondary: #374151;
        --accent: #6366f1;
        --accent-hover: #4f46e5;
        --shadow-intensity: 1;
        --radius-base: 1rem;
        --font-heading: "Playfair Display", serif;
        --font-body: "Inter", system-ui, sans-serif;
      }

      html, body {
        background-color: var(--neumor-bg);
        color: var(--text-primary);
        font-family: var(--font-body);
        margin: 0;
        padding: 0;
      }

      h1, h2, h3 {
        font-family: var(--font-heading);
      }

      /* Botón crítico - evita flash de botones sin estilo */
      .neumor-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background-color: var(--neumor-bg);
        color: var(--text-primary);
        border: none;
        border-radius: var(--radius-base, 1rem);
        padding: 0.875rem 1.75rem;
        font-weight: 600;
        cursor: pointer;
        box-shadow:
          calc(6px * var(--shadow-intensity, 1)) calc(6px * var(--shadow-intensity, 1)) calc(14px * var(--shadow-intensity, 1)) var(--shadow-dark),
          calc(-6px * var(--shadow-intensity, 1)) calc(-6px * var(--shadow-intensity, 1)) calc(14px * var(--shadow-intensity, 1)) var(--shadow-light);
      }

      .neumor-btn-accent {
        background: linear-gradient(135deg, var(--accent), var(--accent-hover));
        color: white;
      }

      /* Card crítico */
      .neumor-card {
        background-color: var(--neumor-bg);
        border-radius: var(--radius-base, 1rem);
        box-shadow:
          calc(8px * var(--shadow-intensity, 1)) calc(8px * var(--shadow-intensity, 1)) calc(20px * var(--shadow-intensity, 1)) var(--shadow-dark),
          calc(-8px * var(--shadow-intensity, 1)) calc(-8px * var(--shadow-intensity, 1)) calc(20px * var(--shadow-intensity, 1)) var(--shadow-light);
      }

      /* Input crítico */
      .neumor-input {
        background-color: var(--neumor-bg);
        color: var(--text-primary);
        border: none;
        border-radius: var(--radius-base, 1rem);
        box-shadow:
          inset calc(4px * var(--shadow-intensity, 1)) calc(4px * var(--shadow-intensity, 1)) calc(10px * var(--shadow-intensity, 1)) var(--shadow-dark),
          inset calc(-4px * var(--shadow-intensity, 1)) calc(-4px * var(--shadow-intensity, 1)) calc(10px * var(--shadow-intensity, 1)) var(--shadow-light);
      }
    </style>

    <!-- 2. Personalization overrides - colores y efectos del cliente -->
    {inlineColorStyles && (
      <style set:html={`html{${inlineColorStyles}}`}></style>
    )}

    <!-- Favicon -->
    {favicon ? (
      <link rel="icon" type="image/png" href={favicon} />
    ) : (
      <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    )}

    <!-- Fonts preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href={defaultFonts} rel="stylesheet" />
    {fontImports && fontImports !== defaultFonts && (
      <link href={fontImports} rel="stylesheet" />
    )}

    <title>{title}</title>

    <!-- Custom CSS Variables from typography/branding -->
    {cssVariables && (
      <style set:html={cssVariables}></style>
    )}
  </head>
  <body>
    <slot />

    <!-- DEBUG PANEL - Solo visible en modo preview -->
    {inlineColorStyles && (
      <script is:inline define:vars={{ inlineColorStyles, cssVariables, theme }}>
        console.log('[Layout HTML] Theme class:', document.documentElement.className);
        console.log('[Layout HTML] Inline styles on html:', document.documentElement.getAttribute('style'));
        console.log('[Layout HTML] inlineColorStyles variable:', inlineColorStyles);
        console.log('[Layout HTML] Computed --accent:', getComputedStyle(document.documentElement).getPropertyValue('--accent'));

        // Log after a small delay to see final computed values
        setTimeout(() => {
          console.log('[Layout HTML] AFTER LOAD - Computed --accent:', getComputedStyle(document.documentElement).getPropertyValue('--accent'));
          console.log('[Layout HTML] AFTER LOAD - html classes:', document.documentElement.className);
          console.log('[Layout HTML] AFTER LOAD - html style:', document.documentElement.getAttribute('style'));
        }, 100);
      </script>
    )}

    <!-- Live Preview Script - Escucha cambios del admin via postMessage -->
    <script is:inline>
      (function() {
        // Solo activar en modo preview
        if (!window.location.search.includes('preview=1')) return;

        // Mapa de border-radius
        const RADIUS_MAP = {
          sharp: '0.25rem',
          soft: '0.5rem',
          rounded: '1rem',
          pill: '2rem'
        };

        // Ajustar luminosidad de color hex
        function adjustLuminosity(hex, percent) {
          const num = parseInt(hex.replace('#', ''), 16);
          const r = Math.min(255, Math.max(0, (num >> 16) + Math.round(2.55 * percent)));
          const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + Math.round(2.55 * percent)));
          const b = Math.min(255, Math.max(0, (num & 0x0000FF) + Math.round(2.55 * percent)));
          return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
        }

        // Convertir hex a rgba
        function hexToRgba(hex, alpha) {
          const num = parseInt(hex.replace('#', ''), 16);
          const r = (num >> 16) & 255;
          const g = (num >> 8) & 255;
          const b = num & 255;
          return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
        }

        window.addEventListener('message', function(event) {
          // Verificar origen del mensaje
          if (!event.data || event.data.source !== 'neumorstudio-admin') return;
          if (event.data.type !== 'update-styles') return;

          console.log('[Preview] Received postMessage:', event.data.type);
          console.log('[Preview] Theme value:', event.data.payload.theme);

          const { theme, skin, colors, typography, effects, branding } = event.data.payload;
          const root = document.documentElement;

          // Aplicar tema (cambiar clase en html)
          if (theme) {
            console.log('[Preview] Applying theme:', theme, 'Current classes:', root.className);
            // Lista completa de todos los temas disponibles
            var allThemes = [
              'dark', 'colorful', 'rustic', 'elegant', 'neuglass', 'neuglass-dark',
              'christmas', 'summer', 'autumn', 'spring',
              'ocean', 'sunset', 'forest', 'midnight', 'rose', 'lavender', 'coral', 'minimal',
              'wellness', 'vintage'
            ];
            // Remover todas las clases de tema existentes
            allThemes.forEach(function(t) {
              root.classList.remove('theme-' + t);
            });
            // Añadir la nueva clase de tema (light no tiene clase)
            if (theme !== 'light') {
              root.classList.add('theme-' + theme);
            }
            console.log('[Preview] New classes:', root.className);
          }

          // Aplicar skin (estilo visual de componentes)
          if (skin !== undefined) {
            console.log('[Preview] Applying skin:', skin);
            var allSkins = ['flat', 'glass', 'material', 'brutalist', 'soft', '3d', 'outline'];
            // Remover todas las clases de skin existentes
            allSkins.forEach(function(s) {
              root.classList.remove('skin-' + s);
            });
            // Añadir la nueva clase de skin (neumorphic/default no tiene clase)
            if (skin && skin !== 'neumorphic') {
              root.classList.add('skin-' + skin);
            }
          }

          // Aplicar colores
          if (colors) {
            if (colors.primary) {
              root.style.setProperty('--color-primary', colors.primary);
            }
            if (colors.secondary) {
              root.style.setProperty('--color-secondary', colors.secondary);
            }
            if (colors.accent) {
              // IMPORTANTE: Actualizar --accent que es la variable que usa el CSS
              root.style.setProperty('--accent', colors.accent);
              root.style.setProperty('--color-accent', colors.accent);
              root.style.setProperty('--accent-hover', adjustLuminosity(colors.accent, -10));
              root.style.setProperty('--accent-light', hexToRgba(colors.accent, 0.1));
              root.style.setProperty('--accent-glow', hexToRgba(colors.accent, 0.4));
            }
          }

          // Aplicar tipografia
          if (typography) {
            if (typography.headingFont && typography.headingFont !== 'system') {
              // Cargar fuente si no esta cargada
              const fontName = typography.headingFont;
              if (!document.querySelector('link[href*="' + fontName.replace(/ /g, '+') + '"]')) {
                const link = document.createElement('link');
                link.href = 'https://fonts.googleapis.com/css2?family=' + fontName.replace(/ /g, '+') + ':wght@400;500;600;700&display=swap';
                link.rel = 'stylesheet';
                document.head.appendChild(link);
              }
              root.style.setProperty('--font-heading', "'" + fontName + "', serif");
            }
            if (typography.bodyFont && typography.bodyFont !== 'system') {
              const fontName = typography.bodyFont;
              if (!document.querySelector('link[href*="' + fontName.replace(/ /g, '+') + '"]')) {
                const link = document.createElement('link');
                link.href = 'https://fonts.googleapis.com/css2?family=' + fontName.replace(/ /g, '+') + ':wght@400;500;600;700&display=swap';
                link.rel = 'stylesheet';
                document.head.appendChild(link);
              }
              root.style.setProperty('--font-body', "'" + fontName + "', system-ui, sans-serif");
            }
            if (typography.baseFontSize) {
              root.style.setProperty('--font-size-base', typography.baseFontSize + 'px');
            }
          }

          // Aplicar efectos
          if (effects) {
            if (effects.borderRadius && RADIUS_MAP[effects.borderRadius]) {
              root.style.setProperty('--radius-base', RADIUS_MAP[effects.borderRadius]);
            }
            if (effects.shadowIntensity !== undefined) {
              const intensity = effects.shadowIntensity / 100;
              root.style.setProperty('--shadow-intensity', intensity.toString());
            }
          }

          // Aplicar branding
          if (branding) {
            if (branding.logoSize) {
              const sizeMap = { sm: '2rem', md: '3rem', lg: '4rem' };
              root.style.setProperty('--logo-size', sizeMap[branding.logoSize] || '3rem');
              root.style.setProperty('--logo-height', sizeMap[branding.logoSize] || '3rem');
            }
            // Actualizar logo en tiempo real
            if (branding.logo) {
              const logoImages = document.querySelectorAll('.logo-img, .nav-logo img, .navbar-logo img, [data-logo]');
              logoImages.forEach(function(img) {
                if (img.tagName === 'IMG') {
                  img.src = branding.logo;
                }
              });
              // Marcar que hay logo disponible
              const logoContainers = document.querySelectorAll('.logo, [data-logo-display]');
              logoContainers.forEach(function(el) {
                el.setAttribute('data-has-logo', 'true');
              });
            }
            // Actualizar modo de visualizacion (logo vs nombre)
            if (branding.logoDisplay) {
              const logoContainers = document.querySelectorAll('.logo, [data-logo-display]');
              logoContainers.forEach(function(el) {
                el.setAttribute('data-logo-display', branding.logoDisplay);
              });
            }
          }

          // Aplicar contenido de texto
          const { content } = event.data.payload;
          console.log('[Preview] Content received:', content ? 'yes' : 'no', 'heroImage:', content?.heroImage);
          if (content) {
            if (content.heroTitle) {
              const el = document.querySelector('.hero-title');
              if (el) el.textContent = content.heroTitle;
            }
            if (content.heroSubtitle) {
              const el = document.querySelector('.hero-subtitle');
              if (el) el.textContent = content.heroSubtitle;
            }
            // Siempre intentar actualizar heroImage si existe en el contenido
            if (content.heroImage) {
              console.log('[Preview] Attempting to update hero image to:', content.heroImage);
              var imageUpdated = false;

              // 1. Buscar .hero-image (HeroClassic, HeroBold)
              var heroImg = document.querySelector('.hero-image');
              if (heroImg && heroImg.tagName === 'IMG') {
                console.log('[Preview] Updating .hero-image');
                heroImg.src = content.heroImage;
                imageUpdated = true;
              }

              // 2. Buscar .hero-bg-image (HeroModern - imagen fullscreen)
              var heroBgImg = document.querySelector('.hero-bg-image');
              if (heroBgImg && heroBgImg.tagName === 'IMG') {
                console.log('[Preview] Updating .hero-bg-image (HeroModern)');
                heroBgImg.src = content.heroImage;
                imageUpdated = true;
              }

              // 3. Buscar elementos con data-hero-image
              var dataHeroImg = document.querySelector('[data-hero-image]');
              if (dataHeroImg && dataHeroImg.tagName === 'IMG') {
                console.log('[Preview] Updating [data-hero-image]');
                dataHeroImg.src = content.heroImage;
                imageUpdated = true;
              }

              // 4. Buscar background-image CSS (fallback)
              var heroSection = document.querySelector('[data-hero-bg]');
              if (heroSection) {
                console.log('[Preview] Updating hero section background');
                heroSection.style.backgroundImage = 'url(' + content.heroImage + ')';
                imageUpdated = true;
              }

              if (!imageUpdated) {
                console.log('[Preview] WARNING: No hero image element found. Looking for any img in hero...');
                // Fallback: buscar cualquier img dentro de un section.hero*
                var heroSection = document.querySelector('section[class*="hero"]');
                if (heroSection) {
                  var anyImg = heroSection.querySelector('img');
                  if (anyImg) {
                    console.log('[Preview] Found fallback img in hero section');
                    anyImg.src = content.heroImage;
                  }
                }
              }
            }
            if (content.address) {
              document.querySelectorAll('[data-content="address"], .footer-address, .contact-address').forEach(function(el) {
                el.textContent = content.address;
              });
            }
            if (content.phone) {
              document.querySelectorAll('[data-content="phone"], .footer-phone, .contact-phone').forEach(function(el) {
                el.textContent = content.phone;
              });
            }
            if (content.email) {
              document.querySelectorAll('[data-content="email"], .footer-email, .contact-email').forEach(function(el) {
                el.textContent = content.email;
              });
            }
          }

          // Aplicar features
          const { features } = event.data.payload;
          if (features) {
            // Titulo y subtitulo de la seccion
            if (features.title) {
              const el = document.querySelector('.features-header h2, #features h2');
              if (el) el.textContent = features.title;
            }
            if (features.subtitle) {
              const el = document.querySelector('.features-header p, #features > .container > .features-header > p');
              if (el) el.textContent = features.subtitle;
            }
            // Items individuales
            if (features.items && features.items.length > 0) {
              const cards = document.querySelectorAll('.feature-card');
              features.items.forEach(function(item, index) {
                if (cards[index]) {
                  const titleEl = cards[index].querySelector('.feature-title, h3');
                  const descEl = cards[index].querySelector('.feature-description, p');
                  const iconEl = cards[index].querySelector('.feature-icon');
                  if (titleEl && item.title) titleEl.textContent = item.title;
                  if (descEl && item.description) descEl.textContent = item.description;
                  if (iconEl && item.iconSvg) iconEl.innerHTML = item.iconSvg;
                }
              });
            }
          }

          // Aplicar sectionsConfig - Mostrar/ocultar y reordenar secciones en tiempo real
          const { sectionsConfig } = event.data.payload;
          if (sectionsConfig && sectionsConfig.sections) {
            console.log('[Preview] Applying sectionsConfig:', sectionsConfig.sections.length, 'sections');

            sectionsConfig.sections.forEach(function(sectionCfg) {
              const sectionEl = document.querySelector('[data-section-id="' + sectionCfg.id + '"]');
              if (sectionEl) {
                // Actualizar visibilidad
                if (sectionCfg.enabled) {
                  sectionEl.style.display = '';
                  console.log('[Preview] Section', sectionCfg.id, 'enabled, order:', sectionCfg.order);
                } else {
                  sectionEl.style.display = 'none';
                  console.log('[Preview] Section', sectionCfg.id, 'disabled');
                }

                // Actualizar orden (CSS order para flexbox)
                if (sectionCfg.order !== undefined) {
                  sectionEl.style.order = sectionCfg.order.toString();
                }
              } else {
                console.log('[Preview] Section element not found:', sectionCfg.id);
              }
            });
          }
        });
      })();
    </script>
  </body>
</html>
